// Generated by CoffeeScript 1.6.3
(function() {
  var Errors, FSWatcher, Readable, Stats, Writable, escape, fs, isAppendable, isCreatable, isFunction, isReadable, isWritable, toDate, _path;

  Stats = require('./Stats');

  Errors = require('./Errors');

  FSWatcher = require('./FSWatcher');

  escape = require('escape-regexp');

  _path = require('path');

  Readable = require('stream').Readable;

  Writable = require('stream').Writable;

  isFunction = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  };

  isReadable = function(flags) {
    return flags === 'r' || flags === 'r+' || flags === 'rs' || flags === 'rs+' || flags === 'w+' || flags === 'wx+' || flags === 'a+' || flags === 'ax+';
  };

  isWritable = function(flags) {
    return flags === 'r+' || flags === 'rs+' || flags === 'w' || flags === 'wx' || flags === 'w+' || flags === 'wx+';
  };

  isAppendable = function(flags) {
    return flags === 'a' || flags === 'ax' || flags === 'a+' || flags === 'ax+';
  };

  isCreatable = function(flags) {
    return flags === 'w' || flags === 'w+' || flags === 'a' || flags === 'a+';
  };

  toDate = function(time) {
    if (typeof time === 'number') {
      return new Date(time * 1000);
    }
    if (time instanceof Date) {
      return time;
    }
    throw new Error("Cannot parse time: " + time);
  };

  fs = (function() {
    fs.prototype._data = null;

    fs.prototype._fileDescriptors = null;

    fs.prototype._fileDescriptorsCounter = 0;

    function fs(tree, info) {
      if (tree == null) {
        tree = {};
      }
      if (info == null) {
        info = {};
      }
      this._data = {};
      this._fileDescriptors = [];
      this._setTree(tree, info);
    }

    fs.prototype._hasFd = function(fd) {
      return typeof this._fileDescriptors[fd] !== 'undefined';
    };

    fs.prototype._hasSubPaths = function(path) {
      var data, found, _ref;
      _ref = this._data;
      for (found in _ref) {
        data = _ref[found];
        if (path !== found && found.match(new RegExp('^' + escape(path))) !== null) {
          return true;
        }
      }
      return false;
    };

    fs.prototype._setAttributes = function(path, attributes) {
      if (attributes == null) {
        attributes = {};
      }
      return this._data[path].stats._setAttributes(attributes);
    };

    fs.prototype._addPath = function(path, data, info) {
      var item, stats, subData, subPath, type, _ref, _results;
      if (data == null) {
        data = '';
      }
      if (info == null) {
        info = {};
      }
      if (typeof info.stats === 'undefined') {
        info.stats = {};
      }
      if (typeof info.mode === 'undefined') {
        info.mode = 777;
      }
      if (typeof info.encoding === 'undefined') {
        info.encoding = 'utf8';
      }
      if (typeof info.source === 'undefined') {
        info.source = null;
      }
      if (path[0] === '@') {
        return this.linkSync(data, path.substr(1));
      }
      if (path[0] === '%') {
        type = 'symlink';
        info = {
          source: data
        };
        path = path.substr(1);
      } else if (typeof data === 'string') {
        type = 'file';
        info = {
          data: data
        };
      } else if (Object.prototype.toString.call(data) === '[object Object]') {
        type = 'directory';
        info = {
          paths: data
        };
      } else {
        throw new Error('Unknown type');
      }
      path = _path.join('/', path);
      stats = new Stats(path, info.stats);
      stats.mode = info.mode;
      this._data[path] = {};
      item = this._data[path];
      item.stats = stats;
      switch (type) {
        case 'directory':
          stats._isDirectory = true;
          if (typeof info.paths !== 'undefined') {
            _ref = info.paths;
            _results = [];
            for (subPath in _ref) {
              subData = _ref[subPath];
              _results.push(this._addPath(_path.join(path, subPath), subData));
            }
            return _results;
          }
          break;
        case 'file':
          stats._isFile = true;
          if (typeof info.data === 'undefined') {
            item.data = new Buffer('', info.encoding);
          } else if (info.data instanceof Buffer) {
            item.data = info.data;
          } else {
            item.data = new Buffer(info.data, info.encoding);
          }
          return stats.blksize = stats.size = item.data.length;
        case 'symlink':
          stats._isSymlink = true;
          return item.source = info.source;
        default:
          throw new Error("Type must be directory, file or symlink, " + type + " given.");
      }
    };

    fs.prototype._expandPaths = function() {
      var data, path, _ref, _results;
      _ref = this._data;
      _results = [];
      for (path in _ref) {
        data = _ref[path];
        _results.push(this._expandPath(path));
      }
      return _results;
    };

    fs.prototype._expandPath = function(path) {
      var match, position, sub, _results;
      match = path.match(/\//g);
      if (match !== null && match.length > 1) {
        sub = path;
        _results = [];
        while (sub !== null) {
          position = sub.lastIndexOf('/');
          if (position > 0) {
            sub = sub.substring(0, sub.lastIndexOf('/'));
            if (typeof this._data[sub] === 'undefined') {
              _results.push(this._addPath(sub, {}));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(sub = null);
          }
        }
        return _results;
      }
    };

    fs.prototype._setTree = function(tree, info) {
      var attributes, data, path;
      if (info == null) {
        info = {};
      }
      for (path in tree) {
        data = tree[path];
        this._addPath(path, data);
      }
      for (path in info) {
        attributes = info[path];
        this._setAttributes(path, attributes);
      }
      return this._expandPaths();
    };

    fs.prototype._realpath = function(path) {
      if (path[0] === '.') {
        path = _path.join('/', path);
      }
      return _path.normalize(path);
    };

    fs.prototype._getSourcePath = function(path) {
      var _ref;
      path = this._realpath(path);
      if ((_ref = this._data[path]) != null ? _ref.stats.isSymbolicLink() : void 0) {
        path = this._data[path].source;
      }
      return path;
    };

    fs.prototype.rename = function(oldPath, newPath, callback) {
      var err;
      try {
        this.renameSync(oldPath, newPath);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.renameSync = function(oldPath, newPath) {
      oldPath = this.realpathSync(oldPath);
      newPath = this._realpath(newPath);
      if (!this.existsSync(oldPath)) {
        Errors.notFound(oldPath);
      }
      if (this.existsSync(newPath)) {
        Errors.alreadyExists(newPath);
      }
      this._data[newPath] = this._data[oldPath];
      delete this._data[oldPath];
      this._data[newPath].stats._path = newPath;
      return this._data[newPath].stats._modifiedAttributes('rename');
    };

    fs.prototype.ftruncate = function(fd, len, callback) {
      var err;
      try {
        this.ftruncateSync(fd, len);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.ftruncateSync = function(fd, len) {
      var data, item;
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      item = this._data[this._fileDescriptors[fd].path];
      data = item.data.toString('utf8');
      if (item.data.length > len) {
        data = data.substr(0, len);
      }
      return this.writeSync(fd, new Buffer(data), 0, data.length, null);
    };

    fs.prototype.truncate = function(path, len, callback) {
      var err;
      try {
        this.truncateSync(path, len);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.truncateSync = function(path, len) {
      var fd;
      path = this._getSourcePath(path);
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      fd = this.openSync(path, 'w');
      if (!this.fstatSync(fd).isFile()) {
        Errors.notFile(path);
      }
      this.ftruncateSync(fd, len);
      return this.closeSync(fd);
    };

    fs.prototype.chown = function(path, uid, gid, callback) {
      var err;
      try {
        this.chownSync(path, uid, gid);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.chownSync = function(path, uid, gid) {
      var fd;
      path = this._getSourcePath(path);
      fd = this.openSync(path, 'r');
      this.fchownSync(fd, uid, gid);
      return this.closeSync(fd);
    };

    fs.prototype.fchown = function(fd, uid, gid, callback) {
      var err;
      try {
        this.fchownSync(fd, uid, gid);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.fchownSync = function(fd, uid, gid) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return this._setAttributes(this._fileDescriptors[fd].path, {
        uid: uid,
        gid: gid
      });
    };

    fs.prototype.lchown = function(path, uid, gid, callback) {
      this.lchownSync(path, uid, gid);
      return callback();
    };

    fs.prototype.lchownSync = function(path, uid, gid) {
      return Errors.notImplemented('lchown');
    };

    fs.prototype.chmod = function(path, mode, callback) {
      var err;
      try {
        this.chmodSync(path, mode);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.chmodSync = function(path, mode) {
      var fd;
      path = this._getSourcePath(path);
      fd = this.openSync(path, 'r', mode);
      this.fchmodSync(fd, mode);
      return this.closeSync(fd);
    };

    fs.prototype.fchmod = function(fd, mode, callback) {
      var err;
      try {
        this.fchmodSync(fd, mode);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.fchmodSync = function(fd, mode) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return this._setAttributes(this._fileDescriptors[fd].path, {
        mode: mode
      });
    };

    fs.prototype.lchmod = function(path, mode, callback) {
      this.lchmodSync(path, mode);
      return callback();
    };

    fs.prototype.lchmodSync = function(path, mode) {
      return Errors.notImplemented('lchmod');
    };

    fs.prototype.stat = function(path, callback) {
      var err;
      try {
        return callback(null, this.statSync(path));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.statSync = function(path) {
      var fd, result;
      path = this._getSourcePath(path);
      fd = this.openSync(path, 'r');
      result = this.fstatSync(fd);
      this.closeSync(fd);
      return result;
    };

    fs.prototype.lstat = function(path, callback) {
      this.lstatSync(path);
      return callback();
    };

    fs.prototype.lstatSync = function(path) {
      return Errors.notImplemented('lstat');
    };

    fs.prototype.fstat = function(fd, callback) {
      var err;
      try {
        return callback(null, this.fstatSync(fd));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.fstatSync = function(fd) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return this._data[this._fileDescriptors[fd].path].stats;
    };

    fs.prototype.link = function(srcpath, dstpath, callback) {
      var err;
      try {
        this.linkSync(srcpath, dstpath);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.linkSync = function(srcpath, dstpath) {
      srcpath = this.realpathSync(srcpath);
      dstpath = this._realpath(dstpath);
      if (!this.existsSync(srcpath)) {
        Errors.notFound(srcpath);
      }
      return this._data[dstpath] = this._data[srcpath];
    };

    fs.prototype.symlink = function(srcpath, dstpath, type, callback) {
      var err;
      if (type == null) {
        type = null;
      }
      if (isFunction(type)) {
        callback = type;
        type = null;
      }
      try {
        this.symlinkSync(srcpath, dstpath);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.symlinkSync = function(srcpath, dstpath, type) {
      if (type == null) {
        type = null;
      }
      srcpath = this.realpathSync(srcpath);
      dstpath = this._realpath(dstpath);
      if (!this.existsSync(srcpath)) {
        Errors.notFound(srcpath);
      }
      return this._addPath('%' + dstpath, srcpath);
    };

    fs.prototype.readlink = function(path, callback) {
      var err;
      try {
        return callback(null, this.readlinkSync(path));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.readlinkSync = function(path) {
      path = this._getSourcePath(path);
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      return path;
    };

    fs.prototype.realpath = function(path, cache, callback) {
      var err;
      if (cache == null) {
        cache = null;
      }
      if (isFunction(cache)) {
        callback = cache;
        cache = null;
      }
      try {
        return callback(null, this.realpathSync(path, cache));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.realpathSync = function(path, cache) {
      if (cache == null) {
        cache = null;
      }
      if (cache !== null && typeof cache[path] !== 'undefined') {
        return cache[path];
      }
      path = this._realpath(path);
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      return path;
    };

    fs.prototype.unlink = function(path, callback) {
      var err;
      try {
        this.unlinkSync(path);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.unlinkSync = function(path) {
      path = this.realpathSync(path);
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      if (!this.statSync(path).isFile()) {
        Errors.notFile(path);
      }
      return delete this._data[path];
    };

    fs.prototype.rmdir = function(path, callback) {
      var err;
      try {
        this.rmdirSync(path);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.rmdirSync = function(path) {
      path = this.realpathSync(path);
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      if (!this.statSync(path).isDirectory()) {
        Errors.notDirectory(path);
      }
      if (this._hasSubPaths(path)) {
        Errors.directoryNotEmpty(path);
      }
      return delete this._data[path];
    };

    fs.prototype.mkdir = function(path, mode, callback) {
      var err;
      if (mode == null) {
        mode = null;
      }
      if (isFunction(mode)) {
        callback = mode;
        mode = null;
      }
      try {
        this.mkdirSync(path, mode);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.mkdirSync = function(path, mode) {
      if (mode == null) {
        mode = null;
      }
      path = this._realpath(path);
      if (this.existsSync(path)) {
        Errors.alreadyExists(path);
      }
      this._addPath(path, {}, {
        mode: mode
      });
      return this._expandPath(path);
    };

    fs.prototype.readdir = function(path, callback) {
      var err;
      try {
        return callback(null, this.readdirSync(path));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.readdirSync = function(path) {
      var data, files, match, name, _ref;
      path = this._getSourcePath(path);
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      if (!this.statSync(path).isDirectory()) {
        Errors.notDirectory(path);
      }
      path = escape(path);
      files = [];
      _ref = this._data;
      for (name in _ref) {
        data = _ref[name];
        if (name !== path && (match = name.match(new RegExp('^' + path + '(.+)$'))) !== null && match[1].match(/\//g).length === 1) {
          files.push(name);
        }
      }
      return files;
    };

    fs.prototype.close = function(fd, callback) {
      var err;
      try {
        this.closeSync(fd);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.closeSync = function(fd) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return delete this._fileDescriptors[fd];
    };

    fs.prototype.open = function(path, flags, mode, callback) {
      var err;
      if (mode == null) {
        mode = null;
      }
      if (isFunction(mode)) {
        callback = mode;
        mode = null;
      }
      try {
        return callback(null, this.openSync(path, flags, mode));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.openSync = function(path, flags, mode) {
      var exists;
      if (mode == null) {
        mode = null;
      }
      path = this._getSourcePath(path);
      exists = this.existsSync(path);
      if ((flags === 'r' || flags === 'r+') && !exists) {
        Errors.notFound(path);
      }
      if ((flags === 'wx' || flags === 'wx+' || flags === 'ax' || flags === 'ax+') && exists) {
        Errors.alreadyExists(path);
      }
      this._fileDescriptors[this._fileDescriptorsCounter] = {
        path: path,
        flags: flags
      };
      if (isCreatable(flags) && !exists) {
        this._addPath(path, '', {
          mode: mode
        });
      }
      this._fileDescriptorsCounter++;
      return this._fileDescriptorsCounter - 1;
    };

    fs.prototype.utimes = function(path, atime, mtime, callback) {
      var err;
      try {
        this.utimesSync(path, atime, mtime);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.utimesSync = function(path, atime, mtime) {
      var fd;
      path = this.realpathSync(path);
      fd = this.openSync(path, 'r');
      this.futimesSync(fd, atime, mtime);
      return this.closeSync(fd);
    };

    fs.prototype.futimes = function(fd, atime, mtime, callback) {
      var err;
      try {
        this.futimesSync(fd, atime, mtime);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.futimesSync = function(fd, atime, mtime) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return this._setAttributes(this._fileDescriptors[fd].path, {
        atime: toDate(atime),
        mtime: toDate(mtime)
      });
    };

    fs.prototype.fsync = function(fd, callback) {
      var err;
      try {
        this.fsyncSync(fd);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.fsyncSync = function(fd) {
      if (!this._hasFd(fd)) {
        return Errors.fdNotFound(fd);
      }
    };

    fs.prototype.write = function(fd, buffer, offset, length, position, callback) {
      var err;
      if (position == null) {
        position = null;
      }
      if (callback == null) {
        callback = null;
      }
      try {
        this.writeSync(fd, buffer, offset, length, position);
        if (callback !== null) {
          return callback(null, length, buffer);
        }
      } catch (_error) {
        err = _error;
        if (callback !== null) {
          return callback(err, null, buffer);
        }
      }
    };

    fs.prototype.writeSync = function(fd, buffer, offset, length, position) {
      var data, fdData, item, oldData, oldFlags, path, stats;
      if (position == null) {
        position = null;
      }
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      fdData = this._fileDescriptors[fd];
      path = fdData.path;
      if (!isWritable(fdData.flags)) {
        Errors.notWritable(path);
      }
      stats = this.fstatSync(fd);
      if (!stats.isFile()) {
        Errors.notFile(path);
      }
      item = this._data[path];
      data = buffer.toString('utf8', offset).substr(0, length);
      if (position !== null) {
        buffer = new Buffer(stats.size);
        oldFlags = fdData.flags;
        fdData.flags = 'r';
        this.readSync(fd, buffer, 0, stats.size, 0);
        fdData.flags = oldFlags;
        oldData = buffer.toString('utf8');
        data = [oldData.slice(0, position), data, oldData.slice(position)].join('');
      }
      item.data = new Buffer(data);
      item.stats.size = data.length;
      item.stats.blksize = data.length;
      return item.stats._modified();
    };

    fs.prototype.read = function(fd, buffer, offset, length, position, callback) {
      var err;
      if (position == null) {
        position = 0;
      }
      if (callback == null) {
        callback = null;
      }
      try {
        this.readSync(fd, buffer, offset, length, position);
        if (callback !== null) {
          return callback(null, length, buffer);
        }
      } catch (_error) {
        err = _error;
        if (callback !== null) {
          return callback(err, 0, buffer);
        }
      }
    };

    fs.prototype.readSync = function(fd, buffer, offset, length, position) {
      var data, item, path;
      if (position == null) {
        position = 0;
      }
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      item = this._fileDescriptors[fd];
      path = item.path;
      if (!isReadable(item.flags)) {
        Errors.notReadable(path);
      }
      if (!this.fstatSync(fd).isFile()) {
        Errors.notFile(path);
      }
      item = this._data[path];
      data = item.data.toString('utf8');
      data = data.substr(position, length);
      buffer.write(data, offset);
      item.stats._accessed();
      return length;
    };

    fs.prototype.readFile = function(filename, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      try {
        return callback(null, this.readFileSync(filename, options));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.readFileSync = function(filename, options) {
      var buffer, data, fd, size;
      if (options == null) {
        options = {};
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = null;
      }
      if (typeof options.flag === 'undefined') {
        options.flag = 'r';
      }
      fd = this.openSync(filename, options.flag);
      size = this.fstatSync(fd).size;
      buffer = new Buffer(size);
      this.readSync(fd, buffer, 0, size, null);
      this.closeSync(fd);
      data = buffer;
      if (options.encoding !== null) {
        data = buffer.toString(options.encoding);
      }
      return data;
    };

    fs.prototype.writeFile = function(filename, data, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      try {
        return callback(null, this.writeFileSync(filename, data, options));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.writeFileSync = function(filename, data, options) {
      var fd;
      if (options == null) {
        options = {};
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = 'utf8';
      }
      if (typeof options.mode === 'undefined') {
        options.mode = 438;
      }
      if (typeof options.flag === 'undefined') {
        options.flag = 'w';
      }
      filename = this._getSourcePath(filename);
      fd = this.openSync(filename, options.flag, options.mode);
      this.writeSync(fd, new Buffer(data, options.encoding), 0, data.length, null);
      this.closeSync(fd);
      return this._expandPath(filename);
    };

    fs.prototype.appendFile = function(filename, data, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      try {
        return callback(null, this.appendFileSync(filename, data, options));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.appendFileSync = function(filename, data, options) {
      var fd, size;
      if (options == null) {
        options = {};
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = 'utf8';
      }
      if (typeof options.mode === 'undefined') {
        options.mode = 438;
      }
      if (typeof options.flag === 'undefined') {
        options.flag = 'w';
      }
      if (typeof data === 'string') {
        data = new Buffer(data, options.encoding);
      }
      fd = this.openSync(filename, options.flag, options.mode);
      size = this.fstatSync(fd).size;
      this.writeSync(fd, data, 0, data.length, size);
      return this.closeSync(fd);
    };

    fs.prototype.watchFile = function(filename, options, listener) {
      if (options == null) {
        options = null;
      }
      if (listener == null) {
        listener = null;
      }
      if (isFunction(options)) {
        listener = options;
        options = null;
      }
      return Errors.notImplemented('watchFile');
    };

    fs.prototype.unwatchFile = function(filename, listener) {
      if (listener == null) {
        listener = null;
      }
      return Errors.notImplemented('unwatchFile');
    };

    fs.prototype.watch = function(filename, options, listener) {
      var stats, watcher;
      if (options == null) {
        options = null;
      }
      if (listener == null) {
        listener = null;
      }
      if (isFunction(options)) {
        listener = options;
        options = null;
      }
      if (!this.existsSync(filename)) {
        Errors.notFound(filename);
      }
      watcher = new FSWatcher(listener);
      stats = this.statSync(filename);
      stats.on('modified', function(stats) {
        return watcher.emit('change', 'change', stats._path);
      });
      stats.on('modifiedAttributes', function(stats, event) {
        return watcher.emit('change', event, stats._path);
      });
      return watcher;
    };

    fs.prototype.exists = function(path, callback) {
      return callback(this.existsSync(path));
    };

    fs.prototype.existsSync = function(path) {
      path = this._realpath(path);
      return typeof this._data[path] !== 'undefined';
    };

    fs.prototype.createReadStream = function(path, options) {
      var buffer, data, fd, rs, size;
      if (options == null) {
        options = {};
      }
      if (typeof options.flags === 'undefined') {
        options.flags = 'r';
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = null;
      }
      if (typeof options.fd === 'undefined') {
        options.fd = null;
      }
      if (typeof options.mode === 'undefined') {
        options.mode = 666;
      }
      if (typeof options.autoClose === 'undefined') {
        options.autoClose = true;
      }
      if (typeof options.start === 'undefined') {
        options.start = null;
      }
      if (typeof options.end === 'undefined') {
        options.end = null;
      }
      if (options.fd === null) {
        fd = this.openSync(path, options.flags, options.mode);
      }
      size = this.fstatSync(fd).size;
      rs = new Readable;
      buffer = new Buffer(size);
      this.readSync(fd, buffer, 0, size, 0);
      data = buffer.toString(options.encoding);
      if (options.start !== null && options.end !== null) {
        data = data.substring(options.start, options.end);
      }
      rs.push(data);
      rs.push(null);
      if (options.autoClose) {
        this.closeSync(fd);
      }
      return rs;
    };

    fs.prototype.createWriteStream = function(path, options) {
      var fd, position, ws,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (typeof options.flags === 'undefined') {
        options.flags = 'w';
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = null;
      }
      if (typeof options.mode === 'undefined') {
        options.mode = 666;
      }
      if (typeof options.start === 'undefined') {
        options.start = 0;
      }
      fd = this.openSync(path, options.flags, options.mode);
      position = options.start;
      ws = Writable();
      ws._write = function(chunk, enc, next) {
        if (typeof chunk === 'string') {
          chunk = new Buffer(chunk);
        }
        return _this.write(fd, chunk, 0, chunk.length, position, function(err) {
          if (err) {
            throw err;
          }
          position += chunk.length;
          return next();
        });
      };
      ws.on('finish', function() {
        return _this.closeSync(fd);
      });
      return ws;
    };

    return fs;

  })();

  module.exports = fs;

}).call(this);
