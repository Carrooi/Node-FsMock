// Generated by CoffeeScript 1.6.3
(function() {
  var Errors, Stats, escape, fs, isAppendable, isFunction, isReadable, isWritable, toDate, _path;

  Stats = require('./Stats');

  Errors = require('./Errors');

  escape = require('escape-regexp');

  _path = require('path');

  isFunction = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Function]';
  };

  isReadable = function(flags) {
    return flags === 'r' || flags === 'r+' || flags === 'rs' || flags === 'rs+' || flags === 'w+' || flags === 'wx+' || flags === 'a+' || flags === 'ax+';
  };

  isWritable = function(flags) {
    return flags === 'r+' || flags === 'rs+' || flags === 'w' || flags === 'wx' || flags === 'w+' || flags === 'wx+';
  };

  isAppendable = function(flags) {
    return flags === 'a' || flags === 'ax' || flags === 'a+' || flags === 'ax+';
  };

  toDate = function(time) {
    if (typeof time === 'number') {
      return new Date(time * 1000);
    }
    if (time instanceof Date) {
      return time;
    }
    throw new Error("Cannot parse time: " + time);
  };

  fs = (function() {
    fs.prototype._data = null;

    fs.prototype._fileDescriptors = null;

    fs.prototype._fileDescriptorsCounter = 0;

    function fs(tree) {
      if (tree == null) {
        tree = {};
      }
      this._data = {};
      this._fileDescriptors = [];
      this._setTree(tree);
    }

    fs.prototype._hasFd = function(fd) {
      return typeof this._fileDescriptors[fd] !== 'undefined';
    };

    fs.prototype._hasSubPaths = function(path) {
      var data, found, _ref;
      _ref = this._data;
      for (found in _ref) {
        data = _ref[found];
        if (path !== found && found.match(new RegExp('^' + escape(path))) !== null) {
          return true;
        }
      }
      return false;
    };

    fs.prototype._setAttributes = function(path, attributes) {
      var name, value;
      if (attributes == null) {
        attributes = {};
      }
      for (name in attributes) {
        value = attributes[name];
        this._data[path].stats[name] = value;
      }
      return this._data[path].stats._modifiedAttributes();
    };

    fs.prototype._addPath = function(path, data, type) {
      var subData, subPath, _ref, _results;
      if (data == null) {
        data = {};
      }
      if (type == null) {
        type = null;
      }
      if (typeof data.stats === 'undefined') {
        data.stats = {};
      }
      if (typeof data.mode === 'undefined') {
        data.mode = 777;
      }
      if (typeof data.encoding === 'undefined') {
        data.encoding = 'utf8';
      }
      if (type === null) {
        if (path.match(/\s>>$/) !== null) {
          path = path.substring(0, path.length - 3);
          type = 'directory';
        } else {
          type = 'file';
        }
      }
      this._data[path] = {
        stats: new Stats(path, data.stats)
      };
      this._data[path].stats.mode = data.mode;
      if (type === 'directory') {
        this._data[path].stats._isDirectory = true;
        if (typeof data.paths !== 'undefined') {
          _ref = data.paths;
          _results = [];
          for (subPath in _ref) {
            subData = _ref[subPath];
            _results.push(this._addPath(path + '/' + subPath, subData));
          }
          return _results;
        }
      } else if (type === 'file') {
        this._data[path].stats._isFile = true;
        if (typeof data.data === 'undefined') {
          this._data[path].data = new Buffer('', data.encoding);
        } else if (data.data instanceof Buffer) {
          this._data[path].data = data.data;
        } else {
          this._data[path].data = new Buffer(data.data, data.encoding);
        }
        return this._data[path].stats.blksize = this._data[path].stats.size = this._data[path].data.length;
      }
    };

    fs.prototype._expandPaths = function() {
      var data, path, _ref, _results;
      _ref = this._data;
      _results = [];
      for (path in _ref) {
        data = _ref[path];
        _results.push(this._expandPath(path));
      }
      return _results;
    };

    fs.prototype._expandPath = function(path) {
      var match, position, sub, _results;
      match = path.match(/\//g);
      if (match !== null && match.length > 1) {
        sub = path;
        _results = [];
        while (sub !== null) {
          position = sub.lastIndexOf('/');
          if (position > 0) {
            sub = sub.substring(0, sub.lastIndexOf('/'));
            if (typeof this._data[sub] === 'undefined') {
              _results.push(this._addPath(sub + ' >>'));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(sub = null);
          }
        }
        return _results;
      }
    };

    fs.prototype._setTree = function(tree) {
      var data, path;
      for (path in tree) {
        data = tree[path];
        this._addPath(path, data);
      }
      return this._expandPaths();
    };

    fs.prototype.rename = function(oldPath, newPath, callback) {
      var err;
      try {
        this.renameSync(oldPath, newPath);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.renameSync = function(oldPath, newPath) {
      if (!this.existsSync(oldPath)) {
        Errors.notFound(oldPath);
      }
      if (this.existsSync(newPath)) {
        Errors.alreadyExists(newPath);
      }
      this._data[newPath] = this._data[oldPath];
      delete this._data[oldPath];
      return this._data[newPath].stats._modifiedAttributes();
    };

    fs.prototype.ftruncate = function(fd, len, callback) {
      var err;
      try {
        this.ftruncateSync(fd, len);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.ftruncateSync = function(fd, len) {
      var data, item;
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      item = this._data[this._fileDescriptors[fd].path];
      data = item.data.toString('utf8');
      if (item.data.length > len) {
        data = data.substr(0, len);
      }
      return this.writeSync(fd, new Buffer(data), 0, data.length, 0);
    };

    fs.prototype.truncate = function(path, len, callback) {
      var err;
      try {
        this.truncateSync(path, len);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.truncateSync = function(path, len) {
      var fd;
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      if (!this.statSync(path).isFile()) {
        Errors.notFile(path);
      }
      fd = this.openSync(path, 'w');
      this.ftruncateSync(fd, len);
      return this.closeSync(fd);
    };

    fs.prototype.chown = function(path, uid, gid, callback) {
      var err;
      try {
        this.chownSync(path, uid, gid);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.chownSync = function(path, uid, gid) {
      var fd;
      fd = this.openSync(path, 'r');
      this.fchownSync(fd, uid, gid);
      return this.closeSync(fd);
    };

    fs.prototype.fchown = function(fd, uid, gid, callback) {
      var err;
      try {
        this.fchownSync(fd, uid, gid);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.fchownSync = function(fd, uid, gid) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return this._setAttributes(this._fileDescriptors[fd].path, {
        uid: uid,
        gid: gid
      });
    };

    fs.prototype.lchown = function(path, uid, gid, callback) {
      this.lchownSync(path, uid, gid);
      return callback();
    };

    fs.prototype.lchownSync = function(path, uid, gid) {
      return Errors.notImplemented('lchown');
    };

    fs.prototype.chmod = function(path, mode, callback) {
      var err;
      try {
        this.chmodSync(path, mode);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.chmodSync = function(path, mode) {
      var fd;
      fd = this.openSync(path, 'r', mode);
      this.fchmodSync(fd, mode);
      return this.closeSync(fd);
    };

    fs.prototype.fchmod = function(fd, mode, callback) {
      var err;
      try {
        this.fchmodSync(fd, mode);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.fchmodSync = function(fd, mode) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return this._setAttributes(this._fileDescriptors[fd].path, {
        mode: mode
      });
    };

    fs.prototype.lchmod = function(path, mode, callback) {
      this.lchmodSync(path, mode);
      return callback();
    };

    fs.prototype.lchmodSync = function(path, mode) {
      return Errors.notImplemented('lchmod');
    };

    fs.prototype.stat = function(path, callback) {
      var err;
      try {
        return callback(null, this.statSync(path));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.statSync = function(path) {
      var fd, result;
      fd = this.openSync(path, 'r');
      result = this.fstatSync(fd);
      this.closeSync(fd);
      return result;
    };

    fs.prototype.lstat = function(path, callback) {
      this.lstatSync(path);
      return callback();
    };

    fs.prototype.lstatSync = function(path) {
      return Errors.notImplemented('lstat');
    };

    fs.prototype.fstat = function(fd, callback) {
      var err;
      try {
        return callback(null, this.fstatSync(fd));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.fstatSync = function(fd) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return this._data[this._fileDescriptors[fd].path].stats;
    };

    fs.prototype.link = function(srcpath, dstpath, callback) {
      this.linkSync(srcpath, dstpath);
      return callback();
    };

    fs.prototype.linkSync = function(srcpath, dstpath) {
      return Errors.notImplemented('link');
    };

    fs.prototype.symlink = function(srcpath, dstpath, type, callback) {
      if (type == null) {
        type = null;
      }
      if (isFunction(type)) {
        callback = type;
        type = null;
      }
      this.symlinkSync(srcpath, dstpath, type);
      return callback();
    };

    fs.prototype.symlinkSync = function(srcpath, dstpath, type) {
      if (type == null) {
        type = null;
      }
      return Errors.notImplemented('symlink');
    };

    fs.prototype.readlink = function(path, callback) {
      this.readlinkSync(path);
      return callback();
    };

    fs.prototype.readlinkSync = function(path) {
      return Errors.notImplemented('readlink');
    };

    fs.prototype.realpath = function(path, cache, callback) {
      var err;
      if (cache == null) {
        cache = null;
      }
      if (isFunction(cache)) {
        callback = cache;
        cache = null;
      }
      try {
        return callback(null, this.realpathSync(path, cache));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.realpathSync = function(path, cache) {
      if (cache == null) {
        cache = null;
      }
      if (cache !== null && typeof cache[path] !== 'undefined') {
        return cache[path];
      }
      if (path[0] === '.') {
        path = _path.join('/', path);
      }
      path = _path.normalize(path);
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      return path;
    };

    fs.prototype.unlink = function(path, callback) {
      var err;
      try {
        this.unlinkSync(path);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.unlinkSync = function(path) {
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      if (!this.statSync(path).isFile()) {
        Errors.notFile(path);
      }
      return delete this._data[path];
    };

    fs.prototype.rmdir = function(path, callback) {
      var err;
      try {
        this.rmdirSync(path);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.rmdirSync = function(path) {
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      if (!this.statSync(path).isDirectory()) {
        Errors.notDirectory(path);
      }
      if (this._hasSubPaths(path)) {
        Errors.directoryNotEmpty(path);
      }
      return delete this._data[path];
    };

    fs.prototype.mkdir = function(path, mode, callback) {
      var err;
      if (mode == null) {
        mode = null;
      }
      if (isFunction(mode)) {
        callback = mode;
        mode = null;
      }
      try {
        this.mkdirSync(path, mode);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.mkdirSync = function(path, mode) {
      if (mode == null) {
        mode = null;
      }
      if (this.existsSync(path)) {
        Errors.alreadyExists(path);
      }
      this._addPath(path, {
        mode: mode
      }, 'directory');
      return this._expandPath(path);
    };

    fs.prototype.readdir = function(path, callback) {
      var err;
      try {
        return callback(null, this.readdirSync(path));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.readdirSync = function(path) {
      var data, files, match, name, _ref;
      if (!this.existsSync(path)) {
        Errors.notFound(path);
      }
      if (!this.statSync(path).isDirectory()) {
        Errors.notDirectory(path);
      }
      path = escape(path);
      files = [];
      _ref = this._data;
      for (name in _ref) {
        data = _ref[name];
        if (name !== path && (match = name.match(new RegExp('^' + path + '(.+)$'))) !== null && match[1].match(/\//g).length === 1) {
          files.push(name);
        }
      }
      return files;
    };

    fs.prototype.close = function(fd, callback) {
      var err;
      try {
        this.closeSync(fd);
        return callback();
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.closeSync = function(fd) {
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      return delete this._fileDescriptors[fd];
    };

    fs.prototype.open = function(path, flags, mode, callback) {
      var err;
      if (mode == null) {
        mode = null;
      }
      if (isFunction(mode)) {
        callback = mode;
        mode = null;
      }
      try {
        return callback(null, this.openSync(path, flags, mode));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.openSync = function(path, flags, mode) {
      var options;
      if (mode == null) {
        mode = null;
      }
      if ((flags === 'r' || flags === 'r+') && !this.existsSync(path)) {
        Errors.notFound(path);
      }
      if ((flags === 'wx' || flags === 'wx+' || flags === 'ax' || flags === 'ax+') && this.existsSync(path)) {
        Errors.alreadyExists(path);
      }
      if ((flags === 'w' || flags === 'w+' || flags === 'a' || flags === 'a+') && !this.existsSync(path)) {
        options = {};
        if (mode !== null) {
          options.mode = mode;
        }
        this.writeFileSync(path, '', options);
      }
      this._fileDescriptors[this._fileDescriptorsCounter] = {
        path: path,
        flags: flags
      };
      this._fileDescriptorsCounter++;
      return this._fileDescriptorsCounter - 1;
    };

    fs.prototype.utimes = function(path, atime, mtime, callback) {
      var err;
      try {
        this.utimesSync(path, atime, mtime);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.utimesSync = function(path, atime, mtime) {
      var fd;
      fd = this.openSync(path, 'r');
      this.futimesSync(fd, atime, mtime);
      return this.closeSync(fd);
    };

    fs.prototype.futimes = function(fd, atime, mtime, callback) {
      var err;
      try {
        this.futimesSync(fd, atime, mtime);
        return callback(null);
      } catch (_error) {
        err = _error;
        return callback(err);
      }
    };

    fs.prototype.futimesSync = function(fd, atime, mtime) {
      var item;
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      item = this._data[this._fileDescriptors[fd].path];
      item.stats.atime = toDate(atime);
      item.stats.mtime = toDate(mtime);
      return item.stats._modifiedAttributes();
    };

    fs.prototype.fsync = function(fd, callback) {
      this.fsyncSync(fd);
      return callback();
    };

    fs.prototype.fsyncSync = function(fd) {
      return Errors.notImplemented('fsync');
    };

    fs.prototype.write = function(fd, buffer, offset, length, position, callback) {
      var err;
      if (callback == null) {
        callback = null;
      }
      try {
        this.writeSync(fd, buffer, offset, length, position);
        if (callback !== null) {
          return callback(null, length, buffer);
        }
      } catch (_error) {
        err = _error;
        if (callback !== null) {
          return callback(err, null, buffer);
        }
      }
    };

    fs.prototype.writeSync = function(fd, buffer, offset, length, position) {
      var data, item, path;
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      path = this._fileDescriptors[fd].path;
      if (!isWritable(this._fileDescriptors[fd].flags)) {
        Errors.notWritable(path);
      }
      if (!this.statSync(path).isFile()) {
        Errors.notFile(path);
      }
      item = this._data[path];
      data = buffer.toString('utf8', offset).substr(0, length);
      item.data = new Buffer(data);
      item.stats.size = data.length;
      item.stats.blksize = data.length;
      return item.stats._modified();
    };

    fs.prototype.read = function(fd, buffer, offset, length, position, callback) {
      var err;
      if (position == null) {
        position = 0;
      }
      if (callback == null) {
        callback = null;
      }
      try {
        this.readSync(fd, buffer, offset, length, position);
        if (callback !== null) {
          return callback(null, length, buffer);
        }
      } catch (_error) {
        err = _error;
        if (callback !== null) {
          return callback(err, 0, buffer);
        }
      }
    };

    fs.prototype.readSync = function(fd, buffer, offset, length, position) {
      var data, item, path;
      if (position == null) {
        position = 0;
      }
      if (!this._hasFd(fd)) {
        Errors.fdNotFound(fd);
      }
      path = this._fileDescriptors[fd].path;
      if (!isReadable(this._fileDescriptors[fd].flags)) {
        Errors.notReadable(path);
      }
      if (!this.statSync(path).isFile()) {
        Errors.notFile(path);
      }
      item = this._data[path];
      data = item.data.toString('utf8');
      data = data.substr(position, length);
      buffer.write(data, offset);
      item.stats._accessed();
      return length;
    };

    fs.prototype.readFile = function(filename, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      try {
        return callback(null, this.readFileSync(filename, options));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.readFileSync = function(filename, options) {
      var buffer, data, fd, size;
      if (options == null) {
        options = {};
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = null;
      }
      if (typeof options.flag === 'undefined') {
        options.flag = 'r';
      }
      fd = this.openSync(filename, options.flag);
      size = this.statSync(filename).size;
      buffer = new Buffer(size);
      this.readSync(fd, buffer, 0, size, null);
      this.closeSync(fd);
      data = buffer;
      if (options.encoding !== null) {
        data = buffer.toString(options.encoding);
      }
      return data;
    };

    fs.prototype.writeFile = function(filename, data, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      try {
        return callback(null, this.writeFileSync(filename, data, options));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.writeFileSync = function(filename, data, options) {
      var fd;
      if (options == null) {
        options = {};
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = 'utf8';
      }
      if (typeof options.mode === 'undefined') {
        options.mode = 438;
      }
      if (typeof options.flag === 'undefined') {
        options.flag = 'w';
      }
      if (!this.existsSync(filename)) {
        this._addPath(filename, {
          data: data,
          mode: options.mode
        });
      }
      fd = this.openSync(filename, options.flag, options.mode);
      this.writeSync(fd, new Buffer(data, options.encoding), 0, data.length, 0);
      this.closeSync(fd);
      this._data[filename].stats._modified();
      return this._expandPath(filename);
    };

    fs.prototype.appendFile = function(filename, data, options, callback) {
      var err;
      if (options == null) {
        options = {};
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }
      try {
        return callback(null, this.appendFileSync(filename, data, options));
      } catch (_error) {
        err = _error;
        return callback(err, null);
      }
    };

    fs.prototype.appendFileSync = function(filename, data, options) {
      if (options == null) {
        options = {};
      }
      if (typeof options.encoding === 'undefined') {
        options.encoding = 'utf8';
      }
      if (typeof options.mode === 'undefined') {
        options.mode = 438;
      }
      if (typeof options.flag === 'undefined') {
        options.flag = 'w';
      }
      if (!this.existsSync(filename)) {
        this._addPath(filename, {
          data: '',
          mode: options.mode
        });
      }
      if (!this.statSync(filename).isFile()) {
        Errors.notFile(filename);
      }
      if (data instanceof Buffer) {
        data = data.toString('utf8');
      }
      data = this._data[filename].data.toString('utf8') + data;
      return this.writeFileSync(filename, data);
    };

    fs.prototype.watchFile = function(filename, options, listener) {
      if (options == null) {
        options = null;
      }
      if (listener == null) {
        listener = null;
      }
      if (isFunction(options)) {
        listener = options;
        options = null;
      }
      return Errors.notImplemented('watchFile');
    };

    fs.prototype.unwatchFile = function(filename, listener) {
      if (listener == null) {
        listener = null;
      }
      return Errors.notImplemented('unwatchFile');
    };

    fs.prototype.watch = function(filename, options, listener) {
      if (options == null) {
        options = null;
      }
      if (listener == null) {
        listener = null;
      }
      if (isFunction(options)) {
        listener = options;
        options = null;
      }
      return Errors.notImplemented('watch');
    };

    fs.prototype.exists = function(path, callback) {
      return callback(this.existsSync(path));
    };

    fs.prototype.existsSync = function(path) {
      return typeof this._data[path] !== 'undefined';
    };

    fs.prototype.createReadStream = function(path, options) {
      if (options == null) {
        options = null;
      }
      return Errors.notImplemented('createReadStream');
    };

    fs.prototype.createWriteStream = function(path, options) {
      if (options == null) {
        options = null;
      }
      return Errors.notImplemented('createWriteStream');
    };

    return fs;

  })();

  module.exports = fs;

}).call(this);
